CREATE OR REPLACE FUNCTION reserve_materials_for_order(
    p_customer_order_id IN NUMBER
) RETURN VARCHAR2 IS
    -- Declare custom exceptions
    CUSTOMER_ORDER_NOT_FOUND EXCEPTION;
    STOCK_INSUFFICIENT EXCEPTION;

    -- Variables
    v_stock_status SYS_REFCURSOR;
    v_part_data VARCHAR2(4000);
    v_status VARCHAR2(20);
    v_reserved_id NUMBER;
    v_part_id VARCHAR2(255);
    v_total_required NUMBER;
    v_available_stock NUMBER;

    -- Variables for checking stock status
    v_is_stock_sufficient BOOLEAN := TRUE;

    -- Cursor to retrieve required parts and their stock status (external parts only)
    CURSOR c_order_parts IS
        SELECT
            cip.Part_ID,
            SUM(cip.Quantity * cop.Quantity) AS Total_Required_Quantity,
            s.Stock AS Available_Stock,
            s.Unit
        FROM
            Customer_Order_Product cop
                JOIN
            BOO_Input cip ON cop.Product_ID = cip.Product_ID
                JOIN
            External_Part ep ON cip.Part_ID = ep.Part_ID  -- Filter to external parts
                LEFT JOIN
            Stock s ON cip.Part_ID = s.Part_ID
        WHERE
            cop.Customer_Order_ID = p_customer_order_id
        GROUP BY
            cip.Part_ID, s.Stock, s.Unit;

BEGIN
    -- Call get_order_stock_status function to check if there is enough stock
    v_stock_status := get_order_stock_status(p_customer_order_id);

    -- Iterate through the stock status results
    LOOP
        FETCH v_stock_status INTO v_part_data;
        EXIT WHEN v_stock_status%NOTFOUND;

        -- Parse the status line for each part
        IF INSTR(v_part_data, 'Status: Insufficient') > 0 THEN
            v_is_stock_sufficient := FALSE;
            EXIT;
        END IF;
    END LOOP;

    -- Close the cursor
    CLOSE v_stock_status;

    -- If stock is insufficient, raise exception
    IF NOT v_is_stock_sufficient THEN
        RAISE STOCK_INSUFFICIENT;
    END IF;

    -- If stock is sufficient, proceed with reservation
    FOR part_record IN c_order_parts LOOP
        -- Generate a new reserved ID
        SELECT NVL(MAX(Reserved_ID), 0) + 1 INTO v_reserved_id FROM Reserved_Stock;

        -- Insert into Reserved_Stock table
        INSERT INTO Reserved_Stock (
            Reserved_ID,
            Part_ID,
            Quantity,
            Unit
        ) VALUES (
            v_reserved_id,
            part_record.Part_ID,
            part_record.Total_Required_Quantity,
            part_record.Unit
        );
    END LOOP;

    -- Return success message
    RETURN 'Reservation Successful';

EXCEPTION
    WHEN CUSTOMER_ORDER_NOT_FOUND THEN
        RETURN 'Error: Customer order not found.';
    WHEN STOCK_INSUFFICIENT THEN
        RETURN 'Error: Insufficient stock for the order.';
    WHEN OTHERS THEN
        RETURN 'Error: ' || SQLERRM;
END reserve_materials_for_order;
/


-- Test with insufficient stock
DECLARE
    v_customer_order_id NUMBER := 4; -- Customer_Order_ID
    v_result VARCHAR2(4000);
BEGIN
    -- Call the ReserveMaterialsForOrder function
    v_result := reserve_materials_for_order(v_customer_order_id);

    -- Output the result
    DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

--Valid test
DECLARE
    v_customer_order_id NUMBER := 1; -- Customer_Order_ID
    v_result VARCHAR2(4000);
BEGIN
    -- Call the ReserveMaterialsForOrder function
    v_result := reserve_materials_for_order(v_customer_order_id);

    -- Output the result
    DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/